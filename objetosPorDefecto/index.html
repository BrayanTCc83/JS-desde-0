<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Objetos</title>
    <link rel="stylesheet" href="../operadores/index.css">
</head>
<body>
    <header id="header" >
        <h1>LOS OBJETOS DENTRO DE JAVASCRIPT</h1>
        <a href="#theme-number">Ir a number</a>
        <a href="#theme-string">Ir a string</a>
        <a href="#theme-array">Ir a array</a>
        <a href="#theme-object">Ir a object</a>
    </header>
    <main>
        <!--
        <h2 id="theme-number" >Number</h2>
        <p>
            Es un objeto que nos permite manipular valores y validar características de números
            o variables que contengan números, esta clase posee constantes, metodos de
            validación y conversión.
            <h3>Constantes</h3>
            <dl>
                <dt>
                    MAX_VALUE
                    <dd>
                        Contiene el límite de valores positivos (<i>R</i>) que es capaz de representar JS
                    </dd>
                </dt>
                <dt>
                    MIN_VALUE
                    <dd>
                        Contiene el límite de valores negativos (<i>R</i>) que es capaz de representar JS
                    </dd>
                </dt>
                <dt>
                    MAX_SAFE_INTEGER
                    <dd>
                        Contiene el límite de valores enteros positivos (<i>N</i>) que es capaz de representar JS
                    </dd>
                </dt>
                <dt>
                    MIN_SAFE_INTEGER
                    <dd>
                        Contiene el límite de valores negativos enteros (<i>Z</i>) que es capaz de representar JS
                    </dd>
                </dt>
                <dt>
                    EPSILON
                    <dd>
                        Usado para obtener el número más pequeño próximo a 0
                    </dd>
                </dt>
                <dt>
                    POSITIVE_INFINITY
                    <dd>
                        Almacena el resultado de obtener un valor tan grande que JS no puede
                        mostrarlo con sus valores soportados, por ejemplo:
                        <br>
                        <i>100**900 ; //Infinity</i>
                    </dd>
                </dt>
                <dt>
                    NEGATIVE_INFINITY
                    <dd>
                        Es el valor que indica un número muy pequeño cuando no es posible
                        representarlo dentro de los estándares de JS, por ejemplo:
                        <br>
                        <i>(-500)**1001 ; //-Infinity</i>
                    </dd>
                </dt>
                <dt>
                    NaN
                    <dd>
                        Notación de no es un número (Not a Number), es el valor que nos 
                        retorna por defecto cuando intentamos usar valor inválido dentro 
                        de una operación, por ejemplo multiplicar una cadena de texto por 
                        un valor:
                        <br>
                        <i>"hola"*5 ; //NaN</i>
                    </dd>
                </dt>
            </dl>
        </p>
        <h3>Funciones de validación</h3>
        <ul>
            <li>isInteger( number )</li>
            <li>isSafeInteger( number )</li>
            <li>isFinite( number )</li>
            <li>isNaN( number )</li>
        </ul>
        <h3>Funciones de conversión</h3>
        <ul>
            <li>toString()</li>
            <li>parseInt( number, base )</li>
            <li>parseFloat( string )</li>
        </ul>
        <hr>
        <h2 id="theme-string" >String</h2>
        <p>
            El objeto string nos pemite manejar cadenas de texto, toda cadena de texto es una extensión
            del objeto string, para ver sus características necesitamos primero crear una cadena de texto,
            entonces encontraremos métodos y propiedades, principalmente de transformación de la cadena,
            obtención, remplazamiento, con muchos de ellos que afectan directamente a la vista en la página web.
            <h3>Propiedades (características de la cadena)</h3>
            <ul>
                <li>
                    <i>Length</i> <br>
                    Retorna el tamaño de caracteres de una cadena, 0 si es vació
                </li>
            </ul>
            <h3>Modificaciones en la cadena de texto</h3>
            <ul>
                <li>
                    <i>toUpperCase()</i> <br>
                    Transforma la cadena a mayúsculas al ser aplicada, solo en el lugar en donde fue utilizada, suele ser útil para compara coincidencia de caracteres entre una cadena local y otra ingresada por un usuario.
                    Existe la variante <b>toLocalUpperCase()</b>, que se usa para escribir caracteres en ciertas regiones.
                </li>
                <li>
                    <i>toLowerCase()</i> <br>
                    Transforma la cadena a minúsculas al ser aplicada, solo en el lugar en donde fue utilizada.
                    Existe la variante <b>toLocalLowerCase()</b>, que se usa para escribir caracteres en ciertas regiones.
                </li>
                <li>
                    <i>concat( string )</i> <br>
                    Devuelve una cadena resultado de la cadena original y la que fue ingresada como parámetro
                </li>
                <li>
                    <i>replace( "toReplace" , "newString" )</i> <br>
                    <i>replace( regexp , "newString" )</i> <br>
                    Remplaza los valores indicados en la cadena o expresión regular, con los que se encuentran en la segunda cadena de texto, permitiendo hacer grandes cambios a la cadena
                </li>
                <li>
                    <i>split( "subString" )</i> <br>
                    <i>split( regexp )</i> <br>
                    Permite separar una cadena en múltiples trozos, segmentados por los caracteres indicados como parámetro, sea string o regexp, lo retorna como un arreglo
                </li>
                <li>
                    <i>substr( start, length )</i> <br>
                    Retorna una nueva cadena de texto, extrayendo todos los caracteres partiendo del índice de inicio (start), que puede ser 0 o cualquier número menor a la longitud de la cadena, hasta extenderse la cantidad de caracteres idicada en length
                </li>
                <li>
                    <i>substring( start, end )</i> <br>
                    Retorna una cadena de texto nueva, entre los indices específicados como parámetros, a diferencia de substr, este recibe ambos valores como posiciones
                </li>
                <li>
                    <i>repeat( count )</i> <br>
                    Permite repetir una cadena multiples veces, indicadas con un número en el contador
                </li>
            </ul>
            <h3>Extraer información de una cadena</h3>
            <ul>
                <li>
                    <i>charAt( index )</i> <br>
                    Retorna el caracter de la posición específicada en el índice, partiendo de 0
                </li>
                <li>
                    <i>macth( regexp )</i> <br>
                    Retorna un arreglo con cada una de las coincidencias encontradas por la expresión regular
                </li>
                <li>
                    <i>search( regexp )</i> <br>
                    Similar a match, pero devolviendo únicamente la primer coincidencia
                </li>
                <li>
                    <i>charCodeAt( index )</i> <br>
                    Retorna el valor en unicode correspondiente al caracter de la posición indicada, es usado para los símbolos cuya representación sea definida en UTF-16, estos incluyen números, el alfabeto latino, cirílico, chino, árabe, japonés, entre otros
                    (Valores menores a 100000 en unicode)
                </li>
                <li>
                    <i>codePointAt( index )</i> <br>
                    Permite conocer el valor en unicode correspondiente al caracter de la posición indicada, es usado para todo símbolo en unicode, estos pueden pertenecer a cualquier alfabeto, silabario, idioma e incluso soporta valores complejos como emojis
                </li>
                <li>
                    <i>indexOf( "char" )</i> <br>
                    Devuelve el índice perteneciente a la primera coincidencia con el valor indicado
                </li>
                <li>
                    <i>lastindexOf( "subString" )</i> <br>
                    <i>lastindexOf( "subString", index )</i> <br>
                    Retorna verdadero si la cadena original termina con la porción de cadena indicada como parámetro, si no se pasa un index, busca coincidencia con la parte final de la cadena
                </li>
                <li>
                    <i>includes( "subString" )</i><br>
                    Devuelve verdadero si alguna parte de la cadena contiene una porción que corresponda a la indicada
                </li>
                <li>
                    <i>startsWith( "subString", index )</i><br>
                    Retorna verdadero siempre y cuando la cadena tenga como primera parte el substring indicado, contando a partir del indice
                </li>
                <li>
                    <i>endsWith( "subString", index )</i><br>
                    Devuleve verdadero siempre y cuando la cadena tenga como ultima parte el substring indicado, contando en reversa a partir del indice
                </li>
            </ul>
            <p id="prueba" ></p>
        </p>
        <hr>
        -->
        <h2 id="theme-array" >Array</h2>
        <p>
            Un array es una estructura de datos que permite almacenar múltiples datos dentro de una misma variable, estos datos pueden ser accedidos mediante sus índices, es decir la posición que tiene el elemento dentro del arreglo
        </p>
        <h3>Declaración</h3>
        <p>
            <b>var a = new Array(13);</b> //Define el tamaño del arreglo <br>
            <b>var b = new Array(1,2);</b> //Contiene los elementos del arreglo <br>
            <b>var c = [1,2];</b> //Definición clásica, con los datos entre corchetes <br>
            <b>var d = new Array( new Array( length | elems ), new Array( length | elems ) );</b> //Define un arreglo multidimensional con constructor<br>
            <b>var d = [["Hola","Adios"],[1,2]];</b> //Define un arreglo multidimensional <br>
        </p>
        <h3>Atributos</h3>
        <ul>
            <li>
                <i>length</i><br>
                Retorna el tamaño que tiene el arreglo, si esta vacio 0, si tiene algún elemento, el número de elementos que tiene.
            </li>
        </ul>
        <h3>Formas de iterar un arreglo</h3>
        <dfn>
            Iterar consiste en recorrer cada una de las posiciones dentro de un arreglo, la primera posición de un arreglo es la 0</dfn>
        <ul>
            <li>
                <i>for</i><br>
                Es posible iterar un arreglo usando un for, donde se defina, el contador de 0 sea menor al tamaño del arreglo 
                <br>
                <b>
                    for( let i = 0; i < array.length ; i++ ){ <br>
                        array[ i ]; <br>
                    }
                </b>
            </li>
            <li>
                <i>for in</i><br>
                El for in es una variación del for, que permite extraer cada una de las posiciones de un arreglo, por ejemplo, si quieres trabajar con más de una cosa con esa posición es una solución sencilla
                <br>
                <b>
                    for( let index in array ){ <br>
                        array[ index ]; <br>
                    }
                </b>
            </li>
            <li>
                <i>for of</i><br>
                Es posible también obtener directamente el elemento que tenemos dentro del arreglo, usando el for of, el cual no retorna la posición, sino el contenido del elemento
                <br>
                <b>
                    for( let value of array ){ <br>
                        element; <br>
                    }
                </b>
            </li>
            <li>
                <i>while</i><br>
                Aunque menos común es posible iterar un arreglo usando el while, de una forma similar al for clásico, aunque termina siendo más sencillo usar alguno de los anteriores
                <br>
                <b>
                    let i = 0;
                    while( i < array.lenght ){ <br>
                        array[ i ]; <br>
                        i++
                    }
                </b>
            </li>
            <li>
                <i>foreach</i><br>
                El foreach, es un método propio del objeto array, el cual itera de forma interna un arreglo y podemos indicar con una función que es lo que se tiene que realizar, esta función debe recibir 0, 1 o hasta 2 parámetros, que serán el contenido y el índice en ese orden
                <br>
                <b>
                    array.foreach( ( element, index ) => { <br>
                        element; <br>
                        index; <br>
                    } )
                </b>
            </li>
            <li>
                <i>map</i><br>
                El map es un método similar a foreach, con principalmente una diferencia, el foreach esta hecho para realizar acciones dentro de la función, mientras que el map, tiende a retornar un valor después de un proceso interno
                <br>
                <b>
                    array.map( ( element, index ) => { <br>
                        return element; <br>
                    } )
                </b>
            </li>
        </ul>
        <h3>Métodos</h3>
        <ul>
            <li>
                <i>fill( value )</i><br>
                <i>fill( value, start )</i><br>
                <i>fill( value, start, end )</i><br>
                Permite rellenar todo el arreglo o una porción del mismo con un valor indicado en value, puede ser un entero, string, boolean, double, objeto, array u otras cosas
            </li>
            <li>
                <i>push( value )</i><br>
                Añade un nuevo elemento al final del arreglo
            </li>
            <li>
                <i>unshift( value )</i><br>
                Añade un elemento al inicio del arreglo
            </li>
            <li>
                <i>pop()</i><br>
                Elimina el último elemento del arreglo y lo devuelve, de esta forma lo podemos recuperar
            </li>
            <li>
                <i>shift()</i><br>
                Elimina el primer elemento del arreglo y lo retorna, a modo de recuperación
            </li>
            <li>
                <i>splice( start )</i><br>
                <i>splice( start, length )</i><br>
                Elimina un conjunto de elementos del arreglo, o lo vacia completamente, indicando donde se inicia en el primer parámetro la posición de incio y el segundo indica cuantos elementos se van a eliminar, retorna todo el conjunto de los elementos eliminados
            </li>
            <li>
                <i>toString()</i><br>
                Parsea el arreglo a una cadena de texto y lo retorna
            </li>
            <li>
                <i>join( string )</i><br>
                Parsea el arreglo a cadena de texto, sustituyendo las comas por el valor o valores que pasemos dentro del string retornandolo
            </li>
            <li>
                <i>concat( array )</i><br>
                <i>concat( values... )</i><br>
                Permite concatenar dos arreglos, o añadir múltiples elementos nuevos al arreglo ya existente, finalmente devuelve el resultado de la concatenación
            </li>
            <li>
                <i>slice()</i><br>
                <i>slice( start )</i><br>
                <i>slice( start, end )</i><br>
                Retorna una copia del arreglo entre las posiciones indicadas, o una copia total del mismo, si no se indica una posición de inicio
            </li>
            <li>
                <i>copyWithin( target, start )</i><br>
                <i>copyWithin( target, start, end )</i><br>
                Copia una parte del arreglo en otra posición distinta, donde el primer parámetro indica la posición donde se inicia la copia del arreglo, el segundo donde inicia la copia, es decir el primer elemento que se copia y el tercer parámetro el último elemento a copiar, si se indica el ultimo, se copia el sobrante del arreglo
            </li>
            <li>
                <i>keys()</i><br>
                Retorna un iterador que contiene cada una de las keys del arreglo, es decir las posiciones del mismo
            </li>
            <li>
                <i>values()</i><br>
                Retorna un iterador que contiene cada una de los values del arreglo, es decir el contenido del array
            </li>
            <li>
                <i>entries()</i><br>
                Retorna un iterador que contiene los arreglos de cada elemento, el primero indicando la posición y el segundo el valor que le corresponde el arreglo
            </li>
            <li>
                <i>reverse()</i><br>
                Coloca en reversa todos los elementos dentro del arreglo
            </li>
            <li>
                <i>includes( value )</i><br>
                <i>includes( value, from )</i><br>
                Retorna si un arreglo contiene el elemento que se busca, a partir de una posición indicada, si no se indica, busca la primer coincidencia en el arreglo, retorna un verdadero o falso según sea el caso
            </li>
            <li>
                <i>find( callback )</i><br>
                Retorna el valor del primer elemento que cumpla con la condición indicada en el callback
                <br>
                <b> value => condition </b>
            </li>
            <li>
                <i>findIndex( callback )</i><br>
                Devuelve el indice del primer elemento que cumpla con la condición indicada
                <br>
                <b> value => condition </b>
            </li>
            <li>
                <i>reduce( callback )</i><br>
                Opera los valores dentro del arreglo, para obtener un único valor, puede indicarse un valor inicial, para la reducción
                <br>
                <b> value => operation </b>
            </li>
            <li>
                <i>reduceRight( callback )</i><br>
                Opera los valores dentro del arreglo, para obtener un único valor, puede indicarse un valor inicial, para la reducción, pero inicia desde la derecha
                <br>
                <b> value => operation </b>
            </li>
            <li>
                <i>sort( callback )</i><br>
                Ordena el arreglo, bajo el criterio indicado en el callback, este siempre se va a comparar con 0 y se ordena con respecto a este valor
                <br>
                <b> value => operation </b> <br>
                por ejemplo, si queremos ordenar de menor a mayor 
                <b> ( a, b ) => a - b </b> <br>
                De mayor a menor
                <b> ( a, b ) => ( (a * -1) - (b * -1) ) </b> //Donde al multiplicar por -1 invertimos el valor
            </li>
            <li>
                <i>filter( callback )</i><br>
                Retorna un arreglo con todos los elementos que cumplan el criterio indicado
                <br>
                <b> value => condition </b>
            </li>
            <li>
                <i>some( callback )</i><br>
                Devuleve un boolean que indica si almenos uno de los elementos cumple con la condición del callback, si ninguno lo hace devuelve falso
                <br>
                <b> value => condition </b>
            </li>
            <li>
                <i>every( callback )</i><br>
                Busca que todos los elementos del arreglo, cumplan con la condición especificada, si alguno falla automaticamente devuelve falso
                <br>
                <b> value => condition </b>
            </li>
        </ul>
        <h2 id="theme-object" >Object</h2>
    </main>
    <script src="./array.js" ></script>
</body>
</html>